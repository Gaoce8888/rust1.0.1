# 生产环境后端对接指南

## 目录
1. [架构概述](#架构概述)
2. [环境准备](#环境准备)
3. [后端API接口](#后端api接口)
4. [前端集成步骤](#前端集成步骤)
5. [测试验证](#测试验证)
6. [部署配置](#部署配置)
7. [故障排除](#故障排除)

## 架构概述

### 系统架构
```
┌─────────────────┐     HTTP/WebSocket    ┌──────────────────┐
│   客户端UI      │ ◄─────────────────────► │   Rust后端       │
│  (NextUI/React) │                        │  (Warp/Tokio)    │
└─────────────────┘                        └──────────────────┘
                                                    │
                                                    ▼
                                           ┌──────────────────┐
                                           │   Redis/Sled     │
                                           │   (数据存储)     │
                                           └──────────────────┘
```

### 通信协议
- **REST API**: 用于登录、文件上传、用户管理等
- **WebSocket**: 用于实时消息传输、在线状态同步

## 环境准备

### 1. 后端服务配置

确保后端服务配置正确：

```toml
# 后端/config/app-config.production.json
{
  "server": {
    "host": "0.0.0.0",
    "port": 6006
  },
  "cors": {
    "allowed_origins": ["http://localhost:8004", "https://your-domain.com"],
    "allow_credentials": true
  }
}
```

### 2. 前端环境变量

创建生产环境配置文件：

```bash
# 前端/客户端UI/.env.production
VITE_API_URL=https://api.your-domain.com
VITE_WS_URL=wss://api.your-domain.com/ws
```

### 3. 依赖安装

```bash
cd 前端/客户端UI
npm install --production
```

## 后端API接口

### 认证接口

#### 登录
```http
POST /auth/login
Content-Type: application/json

{
  "username": "user123",
  "password": "password123",
  "user_type": "Kehu"  // 或 "Kefu"
}

Response:
{
  "session_id": "xxx-xxx-xxx",
  "user_id": "user123",
  "user_name": "张三",
  "user_type": "Kehu"
}
```

#### 登出
```http
POST /auth/logout
Content-Type: application/json

{
  "session_id": "xxx-xxx-xxx"
}
```

### WebSocket连接

```javascript
// WebSocket连接URL格式
ws://localhost:6006/ws?user_id=user123&session_id=xxx-xxx-xxx&user_type=Kehu

// 消息格式
{
  "type": "Chat",
  "from_user_id": "user123",
  "to_user_id": "support001",
  "content": "你好，需要帮助",
  "content_type": "Text",
  "timestamp": "2024-01-20T10:00:00Z"
}
```

### 文件上传

```http
POST /api/files/upload
Content-Type: application/json
X-Session-Id: xxx-xxx-xxx

{
  "file_name": "image.jpg",
  "file_type": "image/jpeg",
  "file_data": "base64编码的文件数据"
}

Response:
{
  "file_id": "file123",
  "url": "/files/file123",
  "file_type": "Image"
}
```

## 前端集成步骤

### 1. 使用企业级适配器

```typescript
// 前端/客户端UI/EnterpriseApp.tsx
import { EnterpriseAdapter } from './services/enterprise-adapter';

// 生产环境配置
const PRODUCTION_CONFIG = {
  apiUrl: import.meta.env.VITE_API_URL || 'https://api.your-domain.com',
  wsUrl: import.meta.env.VITE_WS_URL || 'wss://api.your-domain.com/ws',
  debug: false,
  autoReconnect: true,
  heartbeatInterval: 30000
};

// 初始化适配器
const adapter = EnterpriseAdapter.getInstance(PRODUCTION_CONFIG);
```

### 2. 实现登录流程

```typescript
// 登录处理
const handleLogin = async (username: string, password: string, role: 'customer' | 'support') => {
  try {
    const user = await adapter.login(username, password, role);
    console.log('登录成功:', user);
    // 跳转到聊天界面
  } catch (error) {
    console.error('登录失败:', error);
    // 显示错误信息
  }
};
```

### 3. 消息发送和接收

```typescript
// 发送消息
const sendMessage = async (text: string, receiverId: string) => {
  try {
    await adapter.sendMessage(text, receiverId);
  } catch (error) {
    console.error('发送失败:', error);
  }
};

// 监听新消息
adapter.on('message', (message) => {
  console.log('收到新消息:', message);
  // 更新UI显示新消息
});

// 监听连接状态
adapter.on('connected', () => {
  console.log('WebSocket已连接');
});

adapter.on('disconnected', () => {
  console.log('WebSocket已断开');
});
```

### 4. 文件上传处理

```typescript
// 上传文件
const handleFileUpload = async (file: File) => {
  try {
    const attachment = await adapter.uploadFile(file, (progress) => {
      console.log(`上传进度: ${progress}%`);
    });
    
    // 发送文件消息
    await adapter.sendMessage(attachment.name, receiverId, 'file');
  } catch (error) {
    console.error('文件上传失败:', error);
  }
};
```

## 测试验证

### 1. 单元测试

创建测试文件 `tests/backend-integration.test.ts`:

```typescript
import { EnterpriseAdapter } from '../services/enterprise-adapter';

describe('后端集成测试', () => {
  let adapter: EnterpriseAdapter;
  
  beforeEach(() => {
    adapter = EnterpriseAdapter.getInstance({
      apiUrl: 'http://localhost:6006',
      wsUrl: 'ws://localhost:6006/ws'
    });
  });
  
  test('用户登录', async () => {
    const user = await adapter.login('test_user', 'password', 'customer');
    expect(user).toBeDefined();
    expect(user.id).toBeTruthy();
  });
  
  test('WebSocket连接', async () => {
    await adapter.login('test_user', 'password', 'customer');
    
    return new Promise((resolve) => {
      adapter.on('connected', () => {
        resolve(true);
      });
    });
  });
});
```

### 2. 集成测试脚本

```bash
# 创建测试脚本 test-integration.sh
#!/bin/bash

echo "测试后端连接..."
curl -X POST http://localhost:6006/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test","user_type":"Kehu"}'

echo "测试WebSocket..."
wscat -c "ws://localhost:6006/ws?user_id=test&session_id=test&user_type=Kehu"
```

## 部署配置

### 1. Nginx反向代理配置

```nginx
# /etc/nginx/sites-available/chat-app
server {
    listen 80;
    server_name chat.your-domain.com;
    
    # 前端静态文件
    location / {
        root /var/www/chat-app/dist;
        try_files $uri $uri/ /index.html;
    }
    
    # API代理
    location /api {
        proxy_pass http://localhost:6006;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    
    # WebSocket代理
    location /ws {
        proxy_pass http://localhost:6006;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 2. Docker部署

```dockerfile
# 前端Dockerfile
FROM node:18-alpine as builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
```

### 3. 环境变量管理

```bash
# .env.production
VITE_API_URL=https://api.your-domain.com
VITE_WS_URL=wss://api.your-domain.com/ws

# 构建命令
npm run build -- --mode production
```

## 故障排除

### 常见问题

#### 1. CORS错误
**问题**: 浏览器报告跨域错误
**解决方案**: 
- 检查后端CORS配置
- 确保前端域名在允许列表中

#### 2. WebSocket连接失败
**问题**: WebSocket无法建立连接
**解决方案**:
- 检查防火墙设置
- 确认Nginx正确配置WebSocket代理
- 验证session_id有效性

#### 3. 文件上传失败
**问题**: 大文件上传超时
**解决方案**:
- 增加Nginx client_max_body_size
- 调整后端超时设置
- 实现分片上传

### 调试工具

#### 1. 浏览器开发者工具
```javascript
// 在控制台监控WebSocket
const ws = adapter.ws.ws;
ws.addEventListener('message', (e) => {
  console.log('WS收到:', JSON.parse(e.data));
});
```

#### 2. 网络监控
```bash
# 监控WebSocket连接
tcpdump -i any -A 'port 6006'

# 查看连接状态
netstat -an | grep 6006
```

### 性能优化

#### 1. 连接池管理
- 限制并发WebSocket连接数
- 实现连接复用机制

#### 2. 消息缓存
- 本地缓存最近消息
- 实现消息分页加载

#### 3. 资源优化
- 启用Gzip压缩
- 实现图片懒加载
- 使用CDN加速静态资源

## 安全建议

### 1. HTTPS/WSS
生产环境必须使用加密连接：
- API使用HTTPS
- WebSocket使用WSS

### 2. 认证安全
- 实现Token过期机制
- 使用强密码策略
- 实施登录频率限制

### 3. 数据验证
- 前端输入验证
- 后端二次验证
- XSS防护

## 监控和日志

### 1. 前端监控
```typescript
// 错误上报
window.addEventListener('error', (e) => {
  console.error('全局错误:', e);
  // 上报到监控服务
});

// 性能监控
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    console.log('性能指标:', entry);
  });
});
observer.observe({ entryTypes: ['measure'] });
```

### 2. 后端日志
确保后端记录关键操作日志：
- 用户登录/登出
- 消息发送记录
- 错误日志
- 性能指标

## 总结

成功的生产环境对接需要：
1. ✅ 正确的环境配置
2. ✅ 完整的错误处理
3. ✅ 充分的测试覆盖
4. ✅ 安全的部署流程
5. ✅ 持续的监控维护

如有任何问题，请参考项目文档或联系技术支持团队。 